/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
//RCC BASE ADDRESS 0x4002 3800
//#define RCC_BASE_ADDR (uint32_t*)0x4002 3800
//RCC_AHB1ENR OFFSET 0x30
//#define RCC_AHB1ENR_ADDR (uint32_t*)(*RCC_BASE_ADDR + 0x30)
//GPIOx_MODER 0x40020000 OFFSET 0X00
// 0:1 BITS[15:14] BITS[13:12]
//GPIOx_OTYPER 0x04 -  0 : BITS 6:7 OUTPUT PUSH-PULL

// GPIOx_ODR OFFSET 0x14 :
//int main(void)
//{
//	*(uint32_t*)0x40023830 |= (1<<0);
//	*(uint32_t*)0x40020000 &=  ~( 15 << 12 );
//	*(uint32_t*)0x40020000 |= (1U << 14);
//	*(uint32_t*)0x40020000 |= (1U << 12);
//    /* Loop forever */
//	while(1)
//	{
//
//		*(uint32_t*)0x40020014 ^= (3U << 6);
//
//	}
//}

volatile uint32_t msTicks = 0;

void SysTick_Handler(void) {
    msTicks++;   // tăng mỗi 1ms
}

// Hàm delay
void delay_ms(uint32_t ms) {
    uint32_t start = msTicks;
    while ((msTicks - start) < ms);
}

int main(void)
{
    SystemCoreClockUpdate();                        // cập nhật clock
    SysTick_Config(SystemCoreClock / 1000);         // cấu hình systick 1ms

	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;
	GPIOA->MODER  |= GPIO_MODER_MODER6_0;
	GPIOA->MODER  |= GPIO_MODER_MODER7_0;

	GPIOE->MODER &= ~(GPIO_MODER_MODER3);
	GPIOE->PUPDR |= GPIO_PUPDR_PUPD3_0;

	GPIOA->ODR |= ( GPIO_ODR_OD6 | GPIO_ODR_OD7); // set bit 1 vi` led ở active-low

	while(1)
	{
		if( ! (GPIOE->IDR & (GPIO_IDR_IDR_3)) )
		{
			delay_ms(20);
			while (! (GPIOE->IDR & (GPIO_IDR_IDR_3)) )
			{
				GPIOA->ODR ^= GPIO_ODR_OD6;
				delay_ms(500);
				GPIOA->ODR ^= GPIO_ODR_OD7;
				delay_ms(500);
			}

		}
		else
			GPIOA->ODR |= ( GPIO_ODR_OD6 | GPIO_ODR_OD7); // set bit 1 vi` led ở active-low
	}

}

	/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body (fixed)
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f103x6.h"

#define REG32(BASE,OFFSET) ( *( volatile uint32_t *)(BASE + OFFSET) )

#define RCC_BASEADD     0x40021000UL
#define RCC_CR			REG32(RCC_BASEADD,0X00)
#define RCC_CFGR        REG32(RCC_BASEADD,0X04)
#define RCC_APB2ENR     REG32(RCC_BASEADD,0X18)
#define RCC_APB1ENR		REG32(RCC_BASEADD,0x1C)

#define GPIOA_BASEADD   0x40010800UL
#define GPIOA_CRL       REG32(GPIOA_BASEADD, 0X00)
#define GPIOA_CRH      	REG32(GPIOA_BASEADD, 0X04)
#define GPIOA_IDR       REG32(GPIOA_BASEADD, 0X08)
#define GPIOA_ODR       REG32(GPIOA_BASEADD, 0X0C)

#define SYST_CSR        REG32(0XE000E010,0X00)
#define SYST_RVR        REG32(0XE000E010,0X04)
#define SYST_CVR        REG32(0XE000E010,0X08)
#define SYST_CALIB      REG32(0XE000E010,0X0C)

#define EXTI_BASEADD 	0x40010400
#define EXTI_IMR	REG32(EXTI_BASEADD,0X00)
#define EXTI_EMR 	REG32(EXTI_BASEADD, 0X04)
#define EXTI_RTSR 	REG32(EXTI_BASEADD, 0X08)
#define EXTI_FTSR 	REG32(EXTI_BASEADD, 0X0C)
#define EXTI_PR 	REG32(EXTI_BASEADD, 0X14)
#define AFIO_BASEADD	0x40010000
#define AFIO_EXTICR1	REG32(AFIO_BASEADD, 0X08)

#define USART2_BASEADD	0x40004400
#define USART_SR	REG32(USART2_BASEADD, 0X00)
#define USART_DR	REG32(USART2_BASEADD, 0X04)
#define USART_BRR	REG32(USART2_BASEADD, 0X08)
#define USART_CR1	REG32(USART2_BASEADD, 0X0C)
#define USART_CR2	REG32(USART2_BASEADD, 0X10)
#define USART_CR3	REG32(USART2_BASEADD, 0X14)
#define USART_GTPR	REG32(USART2_BASEADD, 0X18)


volatile uint32_t pins[] = { (1U<<8), (1U<<9), (1U<<10), (1U<<11), (1U<<12) };

volatile uint32_t msTick = 0;

void SysTick_Handler(void)
{
    msTick++;
}

static void my_delay(uint32_t delay)
{
    uint32_t start = msTick;
    while ((msTick - start) < delay) { /* wait */ }
}

void Sys_Init(void)
{
    /* Bật HSE và chuyển SYSCLK = HSE (8 MHz) */
    RCC_CR |= (1U << 16);                           // HSEON
    while ((RCC_CR & (1U << 17)) == 0U) {}          // đợi HSERDY
    RCC_CFGR = (RCC_CFGR & ~0x3U) | 0x1U;           // SW = 01 (HSE)
    while (((RCC_CFGR >> 2) & 0x3U) != 0x1U) {}     // đợi SWS = 01

    /* Clock cho GPIOA */
    RCC_APB2ENR |= (1U << 2);

    /* PA8..PA12 = Output push-pull 2 MHz (CNF=00, MODE=10 -> nibble = 0x2) */
    GPIOA_CRH &= ~((0xFU << 0) | (0xFU << 4) | (0xFU << 8) | (0xFU << 12) | (0xFU << 16));
    GPIOA_CRH |=  ((0x2U << 0) | (0x2U << 4) | (0x2U 	<< 8) | (0x2U << 12) | (0x2U << 16));

    /* SysTick 1 ms với HCLK = 8 MHz */
    SYST_RVR = (8000000UL / 1000UL) - 1UL;
    SYST_CVR = 0;
    SYST_CSR = (1U<<2) | (1U<<1) | (1U<<0);     // CLKSOURCE=HCLK, TICKINT=1, ENABLE=1

    //CONFIG USART
    RCC_APB1ENR |= (1U << 17);
    //TX-A2 RX-A3
    GPIOA_CRL &= ~( (0XFU << (2*4)) | (0XFU << (3*4)) );
    GPIOA_CRL |=  ( (0xBU<<(2*4)) | (0x8U<<(3*4)) );
    GPIOA_ODR  |=  (1U<<3);

    USART_CR1 = 0;            // 8N1 mặc định: M=0, PCE=0
    USART_CR2 = 0;            // STOP=00
    USART_CR3 = 0;

    //8HMZ -> 9600 BRR
    //baudrate = fck / 16*(USARTDIV) => DIV_Mantissa = 52; DIV_Fraction = 0.083 = 1
    USART_BRR = (52<<4) | 1;
	USART_CR1 = (1U<<13) | (1U<<3) | (1U<<2); // UE | TE | RE
	USART_CR1 &= ~(1U<<12);

}

//Cấu hình truyền USART - TX
//1.Kiểm tra xem thanh ghi data có trống hay không bằng cờ TXE, nếu cờ TXE = 1 thì có thể ghi dữ liệu vào thanh ghi data để gửi đi.
//2.Ghi dữ liệu vào thanh ghi data USART_DR.
//3.Đợi đến khi data truyền xong bằng cờ TC (TC = 1).

void UART_WriteChar(uint8_t data)
{
    while( !(USART_SR & (1<<7)) );
    USART_DR = data;
    while( !(USART_SR & (1<<6)) );
}
void UART_WriteString(const char *str)
{
	while(*str){
		UART_WriteChar(*str++);
	}
}

uint8_t UART_Receive(void)
{
	while(!( USART_SR & (1<<5)) )
	{
		if (USART_SR & ( (1<<3) | (1<<2) | (1<<1) | (1<<0) ) ) //CHECK ERROR
			{
				// Error handling: Read DR to clear error flags
				(void)USART_DR;
				return 0xFF; // Return error value
			}
	}
    return (uint8_t)USART_DR;

}
void EXTI0_IRQHandler(void)
{
	if( (EXTI_PR & ( 1U<<0)) )
	{
		EXTI_PR = (1U<<0);
		GPIOA_ODR &= ~((1U<<8) | (1U<<9) | (1U<<10) | (1U<<11) | (1U<<12));
		GPIOA_ODR |= pins[0];
		for(int i= 0;i<200;i++);
	}
}
void EXTI1_IRQHandler(void)
{
	if( (EXTI_PR & ( 1U<<1 )) ) // bit1 == 1 pending ISR
	{
		EXTI_PR = (1U<<1); //write 1 to clear
		GPIOA_ODR &= ~((1U<<8) | (1U<<9) | (1U<<10) | (1U<<11) | (1U<<12));
		GPIOA_ODR |= pins[1];
		for(int i= 0;i<200;i++);

	}
}

int main(void)
{
    Sys_Init();

    /* Loop forever */
    UART_WriteString("READY\r\n");
    while (1)
    {
    	uint8_t c = UART_Receive();
    	switch (c) {
    	  case '1': GPIOA_ODR ^= (1U<<8);  break;
    	  case '2': GPIOA_ODR ^= (1U<<9);  break;
    	  case '3': GPIOA_ODR ^= (1U<<10); break;
    	  case '4': GPIOA_ODR ^= (1U<<11); break;
    	  case '5': GPIOA_ODR ^= (1U<<12); break;
    	  case '\r': UART_WriteString("\r\n"); break; // Enter từ PuTTY thường là '\r'
    	  default: break;
    	}




    }
}
